## 前端的面试问题以及要探究的问题总结

### JS基础

- 原型[[prototype]]

- 闭包

- prototype和__proto__的关系是什么


- 作用域：词法作用域，动态作用域
- meta viewport原理


- this：this的指向，顺带可以提一下 es6 中箭头函数没有 this, arguments, super 等，这些只依赖包含箭头函数最接近的函数


- call，apply，bind 三者用法和区别：参数、绑定规则（显示绑定和强绑定），运行效率（最终都会转换成一个一个的参数去运行）、运行情况（call，apply 立即执行，bind 是return 出一个 this “固定”的函数，这也是为什么 bind 是强绑定的一个原因）

- 变量声明提升：js 代码在运行前都会进行 AST 解析，函数申明默认会提到当前作用域最前面，变量申明也会进行提升。但赋值不会得到提升。关于 AST 解析，这里也可以说是形成词法作用域的主要原因
- JS如何实现重载和多态
- js的基本类型有哪些？引用类型有哪些？null和undefined的区别。Object是引用类型嘛？引用类型和基本类型有什么区别？哪个是存在堆哪一个是存在栈上面的？
- es6的继承和es5的继承有什么区别？
- Nodejs中的Stream和Buffer有什么区别？
- ajax的了解，原生ajax的status和statuscode有哪些对应那些状态？原生ajax的实现步骤
- 函数的作用域是什么？
- 说出event对象的3-5个属性或方法
- js如何实现数组的浅拷贝和深拷贝
- 如何将数组转换为字符串，如何将字符串转换为整数，parseInt的第二个参数代表什么
- JavaScript 实现同时发多个请求
- 怎么规避内存泄漏
- WebSocket 的优点
- 原型继承与类继承的区别
- JavaScript 怎么实现 OOP
- 45分钟内写一个类似百度的自动补全的搜索框，需要实现用鼠标和键盘上下键都能选取补全列表中的item
- 浏览器内核
- 死锁的条件以及解决方案



### ES6基础
- let，const：let 产生块级作用域（通常配合 for 循环或者 {} 进行使用产生块级作用域），const 申明的变量是常量（内存地址不变）

- Promise：这里你谈 promise 的时候，除了将他解决的痛点以及常用的 API 之外，最好进行拓展把 eventloop 带进来好好讲一下，microtask、macrotask 的执行顺序，如果看过 promise 源码，最好可以谈一谈 原生 Promise 是如何实现的。Promise 的关键点在于callback 的两个参数，一个是 resovle，一个是 reject。还有就是 Promise 的链式调用（Promise.then()，每一个 then 都是一个责任人）。

- Generator：遍历器对象生成函数，最大的特点是可以交出函数的执行权

    - function 关键字与函数名之间有一个星号；
    - 函数体内部使用 yield 表达式，定义不同的内部状态；
    - next 指针移向下一个状态

    这里你可以说说 Generator 的异步编程，以及它的语法糖 async 和 awiat，传统的异步编程。ES6 之前，异步编程大致如下

    - 回调函数
    - 事件监听
    - 发布/订阅

    传统异步编程方案之一：协程，多个线程互相协作，完成异步任务。

- async、await：Generator 函数的语法糖。有更好的语义、更好的适用性、返回值是 Promise。

- AMD，CMD，CommonJs，ES6 Module：解决原始无模块化的痛点
    - AMD：requirejs 在推广过程中对模块定义的规范化产出，提前执行，推崇依赖前置
    - CMD：seajs 在推广过程中对模块定义的规范化产出，延迟执行，推崇依赖就近
    - CommonJs：模块输出的是一个值的 copy，运行时加载，加载的是一个对象（module.exports 属性），该对象只有在脚本运行完才会生成
    - ES6 Module：模块输出的是一个值的引用，编译时输出接口，ES6 模块不是对象，它对外接口只是一种静态定义，在代码静态解析阶段就会生成。

- Promise 和 callback 的区别
- Node.js 怎么实现多线程
- 服务器处理请求的时候怎么辨析用户身份，多个应用呢？
- 不同模块规范的区别
- token 的实现原理
- 组件的 GC 问题
- 事件机制（W3C 标准）
- 事件代理
- postMessage 的安全隐患
- BigPipe 的实现原理利用到 HTTP 协议的哪部分
- 用 bash 查找日志中请求时间最长的请求记录
- 怎么判断一个字符串是否回文


### 计算机相关
- 递归和循环哪个性能更好？
- 操作系统中的堆和栈是怎么分配的
- 手写二叉排序树的插入算法;找出二叉树节点间的最大距离。

### 网站相关
- 跨域,跨域方法有哪些？
- xss攻击和CSRF攻击
- cookie和session
- http 缓存
- https（对是https）有几次握手和挥手？https的原理。http有几次挥手和握手？TLS的中文名？TLS在哪一网络层？
- 前后端分离的缺点优点？怎么做？
- tcp在哪一层？http在哪一层？ip在哪一层？tcp的三次握手和四次挥手画图（当场画写ack 和 seq的值）？为什么tcp要三次握手四次挥手？
- get和post请求的区别？什么情况下用到？
-  readyState的几个值分别代表什么状态，当readyState为3的时候把网线拔了会怎样
- Ajax上传文件
- http状态码和http报头
- 你对异步模型有哪些理解？
- webstorage

### css相关
- html5语义化标签举例
- less和sass
- 流式布局如何实现，响应式布局如何实现
- CSS3 新增的属性
- Reflow和Repaint的区别？如何避免重绘？
- float、position的特点
- CSS中的长度单位
- resize和scroll事件的性能优化
- 左边定宽，右边自适应方案：float + margin，float + calc
    ```css
    /* 方案1 */
.left {
  width: 120px;
  float: left;
}
.right {
  margin-left: 120px;
}
/* 方案2 */
.left {
  width: 120px;
  float: left;
}
.right {
  width: calc(100% - 120px);
  float: left;
}
```

- 左右两边定宽，中间自适应：float，float + calc, 圣杯布局（设置BFC，margin负值法），flex
    ```css
    .wrap {
  width: 100%;
  height: 200px;
}
.wrap > div {
  height: 100%;
}
/* 方案1 */
.left {
  width: 120px;
  float: left;
}
.right {
  float: right;
  width: 120px;
}
.center {
  margin: 0 120px;
}
/* 方案2 */
.left {
  width: 120px;
  float: left;
}
.right {
  float: right;
  width: 120px;
}
.center {
  width: calc(100% - 240px);
  margin-left: 120px;
}
/* 方案3 */
.wrap {
  display: flex;
}
.left {
  width: 120px;
}
.right {
  width: 120px;
}
.center {
  flex: 1;
}
```

- 左右居中
    - 行内元素: text-align: center
    - 定宽块状元素: 左右 margin 值为 auto
    - 不定宽块状元素: table布局，position + transform

    ```css
    /* 方案1 */
.wrap {
  text-align: center
}
.center {
  display: inline;
  /* or */
  /* display: inline-block; */
}
/* 方案2 */
.center {
  width: 100px;
  margin: 0 auto;
}
/* 方案2 */
.wrap {
  position: relative;
}
.center {
  position: absulote;
  left: 50%;
  transform: translateX(-50%);
}
```

- 上下垂直居中：
    - 定高：margin，position + margin(负值)
    - 不定高：position + transform，flex，IFC + vertical-align:middle
    ```css
    /* 定高方案1 */
.center {
  height: 100px;
  margin: 50px 0;
}
/* 定高方案2 */
.center {
  height: 100px;
  position: absolute;
  top: 50%;
  margin-top: -25px;
}
/* 不定高方案1 */
.center {
  position: absolute;
  top: 50%;
  transform: translateY(-50%);
}
/* 不定高方案2 */
.wrap {
  display: flex;
  align-items: center;
}
.center {
  width: 100%;
}
/* 不定高方案3 */
/* 设置 inline-block 则会在外层产生 IFC，高度设为 100% 撑开 wrap 的高度 */
.wrap::before {
  content: '';
  height: 100%;
  display: inline-block;
  vertical-align: middle;
}
.wrap {
  text-align: center;
}
.center {
  display: inline-block;
  vertical-align: middle;
}
```


- 怎么样禁止浏览器默认事件？怎么样防止冒泡？

- 盒模型：content（元素内容） + padding（内边距） + border（边框） + margin（外边距）
    - content-box：默认值，总宽度 = margin + border + padding + width
    - border-box：盒子宽度包含 padding 和 border，总宽度 = margin + width
    - inherit：从父元素继承 box-sizing 属性


- BFC、IFC、GFC、FFC：FC（Formatting Contexts），格式化上下文
    - float 的值不为 none。
    - float 的值不为 none。
    - float 的值不为 none。
    - display 的值为 table-cell, table-caption, inline-block中的任何一个。

### 框架相关
- 数据双向绑定原理：常见数据绑定的方案
    - Object.defineProperty（vue）：劫持数据的 getter 和 setter
    - 脏值检测（angularjs）：通过特定事件进行轮循
    - 发布/订阅模式：通过消息发布并将消息进行订阅


- VDOM：三个 part
    - 虚拟节点类，将真实 DOM 节点用 js 对象的形式进行展示，并提供 render 方法，将虚拟节点渲染成真实 DOM
    - 节点 diff 比较：对虚拟节点进行 js 层面的计算，并将不同的操作都记录到 patch 对象
    - re-render：解析 patch 对象，进行 re-render


- vue 和 react 区别
    - 相同点：都支持 ssr，都有 vdom，组件化开发，实现 webComponents 规范，数据驱动等
    - 不同点：vue 是双向数据流（当然为了实现单数据流方便管理组件状态，vuex 便出现了），react 是单向数据流。vue 的 vdom 是追踪每个组件的依赖关系，不会渲染整个组件树，react 每当应该状态被改变时，全部子组件都会 re-render。


- 为什么用 vue （框架选择）
- Vue的优点和缺点
- Vue.js 组件通信方式
- 用 Vue.js 实现分页组件
- JavaScript 垃圾回收的方法
- Koa2 和 Koa1 的区别
- Async & Await
- 前端路由的实现原理
- Webpack 的工作原理
- Vue.js 组件的生命周期
- HTTP2 新特性
- 前端优化策略列举
- 首屏、白屏时间如何计算
- 事件模型解释，target、currentTarget、relatedTarget有什么区别？
- 兼容ie6的水平垂直居中
- 兼容ie的事件封装
- 编写h5需要注意什么
- 如何实现点击radio的文字描述控制radio的状态（通过label实现）
- css优先级
- amd和cmd区别，怎么了解到这些区别的，是否是去看了规范
- 设计模式
- 面向切面编程和函数式编程听
